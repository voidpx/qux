const console = @import("console.zig");
const std = @import("std");
pub const InputHandler = struct {
    control: *const fn(code:u32) void,	
    input: *const fn(char:u32) void,
};

var kbd_state = std.bit_set.IntegerBitSet(8).initEmpty();

var inputHandlers = [_]?*const InputHandler{null} ** 8;
const up_bit:u16 = 1<<7;
const ctrl_left_down:u16 = 0x1d;
const ctrl_left_up:u16 = ctrl_left_down | up_bit;
const ctrl_right_down:u16 = 0xe01d;
const ctrl_right_up:u16 = ctrl_right_down | up_bit;

const shift_left_down:u16 = 0x2a;
const shift_left_up:u16 = shift_left_down | up_bit;
const shift_right_down:u16 = 0x36;
const shift_right_up:u16 =shift_right_down | up_bit;

const alt_left_down:u16 = 0x38;
const alt_left_up:u16 = alt_left_down | up_bit;
const alt_right_down:u16 = 0xe038;
const alt_right_up:u16 = alt_right_down | up_bit;

const ModKey = enum(u8) {
    ctrl = 0,
    shift,
    alt,
    capslock,
    e0
};

// copied from linux
const keymap_plain = [_]u16 {
        0xf200,	0xf01b,	0xf031,	0xf032,	0xf033,	0xf034,	0xf035,	0xf036,
	0xf037,	0xf038,	0xf039,	0xf030,	0xf02d,	0xf03d,	0xf07f,	0xf009,
	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
	0xfb6f,	0xfb70,	0xf05b,	0xf05d,	0xf20a,	0xf702,	0xfb61,	0xfb73,
	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf03b,
	0xf027,	0xf060,	0xf700,	0xf05c,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
	0xfb62,	0xfb6e,	0xfb6d,	0xf02c,	0xf02e,	0xf02f,	0xf700,	0xf30c,
	0xf703,	0xf020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03c,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};

const keymap_shift = [_]u16 {
	0xf200,	0xf01b,	0xf021,	0xf040,	0xf023,	0xf024,	0xf025,	0xf05e,
	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf009,
	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf20a,	0xf702,	0xfb41,	0xfb53,
	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf03a,
	0xf022,	0xf07e,	0xf700,	0xf07c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf700,	0xf30c,
	0xf703,	0xf020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf213,	0xf203,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};

const keymap_ctrl = [_]u16 {
	0xf200,	0xf200,	0xf200,	0xf000,	0xf01b,	0xf01c,	0xf01d,	0xf01e,
	0xf01f,	0xf07f,	0xf200,	0xf200,	0xf01f,	0xf200,	0xf008,	0xf200,
	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
	0xf00f,	0xf010,	0xf01b,	0xf01d,	0xf20a,	0xf702,	0xf001,	0xf013,
	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
	0xf007,	0xf000,	0xf700,	0xf01c,	0xf01a,	0xf018,	0xf003,	0xf016,
	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf700,	0xf30c,
	0xf703,	0xf000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};


inline fn toggleCapslock() void {
    kbd_state.toggle(@intFromEnum(ModKey.capslock));
}

inline fn isShift() bool {
    const cp: u8 = @intFromBool(kbd_state.isSet(@intFromEnum(ModKey.capslock)));
    const sft: u8 = @intFromBool(kbd_state.isSet(@intFromEnum(ModKey.shift)));
    return (cp ^ sft) > 0;
}

inline fn isMod(mod: ModKey) bool {
    return kbd_state.isSet(@intFromEnum(mod));
}

inline fn setMod(mod: ModKey) void {
     kbd_state.set(@intFromEnum(mod));
}

inline fn clrMod(mod:ModKey) void {
    kbd_state.unset(@intFromEnum(mod));
}

pub fn handleInput(keycode:u32) void {
    if (keycode == 0xe0) {
        setMod(.e0);
        return;
    }
    var key = keycode;
    if (isMod(.e0)) {
        key |= (0xe0 << 8);
        clrMod(.e0);
    }

    var c = switch (key) {
        shift_left_down, shift_right_down => {setMod(.shift); return;},
        shift_left_up, shift_right_up => {clrMod(.shift); return;},
        ctrl_left_down, ctrl_right_down => {setMod(.ctrl); return;},
        ctrl_left_up, ctrl_right_up => {clrMod(.ctrl); return;},
        alt_left_down, alt_right_down => {setMod(.alt); return;},
        alt_left_up, alt_right_up => {clrMod(.alt); return;},
        else => key
    };
    if ((c & 0x80) > 0) {
        // release
        // XXX: propogate event
        return;
    }
    const kc = c;
    c &= 0x7f;
    if (c == 0x3a) {
        toggleCapslock();
        return;
    }

    const kmap = if (isShift()) 
        &keymap_shift
     else if (isMod(.ctrl)) 
        &keymap_ctrl
     else &keymap_plain;

    const char = kmap[c];
    for (inputHandlers) |h| {
	const f = h orelse continue;
	if ((kc>>8) == 0xe0) {
	    f.control(c & 0xff);
	} else {
	    f.input(char & 0xff);
	}
    }
}

pub fn registerInputHandler(handler: *const InputHandler) void {
    for (inputHandlers, 0..) |h, i| {
        if (h == null) {
            inputHandlers[i] = handler;
            break;
        }
    }
}


